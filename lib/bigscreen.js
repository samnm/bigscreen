// Generated by CoffeeScript 1.4.0
(function() {
  var ad, app, browser, exec, executeCommand, executeOpen, executeWatch, express, ffmpeg, makeRequest, mdns, os, parseOpenCommand, parsePlainTextCommand, parseWatchCommand, puts, readline, request, requestCommand, rl, servers, streams, sys;

  mdns = require('mdns');

  express = require('express');

  sys = require('sys');

  exec = require('child_process').exec;

  os = require('os');

  ffmpeg = require('fluent-ffmpeg');

  request = require('request');

  readline = require('readline');

  /* 
    Server
  */


  puts = function(error, stdout, stderr) {
    return sys.puts(stdout);
  };

  executeCommand = function(command) {
    switch (command.type) {
      case 'watch':
        return executeWatch(command);
      case 'open':
        return executeOpen(command);
      default:
        return console.log("Received bad command, ", command);
    }
  };

  executeOpen = function(command) {
    return exec("open " + command.url, puts);
  };

  executeWatch = function(command) {};

  streams = {};

  ad = mdns.createAdvertisement(mdns.tcp('http'), 4321, {
    name: "BigScreen@" + (os.hostname())
  });

  ad.start();

  app = express();

  app.use(express.json());

  app.post('/url', function(req, res) {
    return executeCommand(req.body.command.url);
  });

  app.post('/play', function(req, res) {
    return executeCommand(req.body.command.url);
  });

  app.post('/open', function(req, res) {
    return executeCommand(req.body.command.url);
  });

  app.post('/stream', function(req, res) {
    return executeCommand(req.body.command.url);
  });

  app.get('/stream/:file', function(req, res) {
    var proc;
    res.contentType('flv');
    return proc = new ffmpeg({
      source: stream[req.params.file],
      nolog: true
    }).usingPreset("flashvideo").writeToStream(res, function(retcode, error) {
      if (!error) {
        console.log("file has been converted succesfully");
      }
      if (error) {
        return console.log(error);
      }
    });
  });

  app.listen(4321);

  /* 
    Client
  */


  makeRequest = function(server, params) {
    var options;
    if (params == null) {
      params = {};
    }
    options = {
      uri: "http://" + server.host + ":" + server.port + "/url",
      json: params
    };
    return request.post(options, function(error, response, body) {
      console.log(error);
      return console.log(body);
    });
  };

  requestCommand = function(rawCommand) {
    var params;
    params = {
      command: parsePlainTextCommand(rawCommand)
    };
    return makeRequest(servers["BigScreen@" + (os.hostname())], params);
  };

  parseWatchCommand = function(param) {
    return {
      type: 'watch',
      query: param.join(' ')
    };
  };

  parseOpenCommand = function(url) {
    return {
      type: 'open',
      url: url
    };
  };

  parsePlainTextCommand = function(raw) {
    var body, command, components;
    components = raw.split(' ');
    command = components[0];
    body = raw.substring(components[0].length + 1);
    switch (components[0]) {
      case 'watch':
        return parseWatchCommand(body);
      case 'open':
        return parseOpenCommand(body);
      default:
        return parseOpenCommand(raw);
    }
  };

  browser = mdns.createBrowser(mdns.tcp('http'));

  servers = {};

  browser.on('serviceUp', function(service) {
    console.log('service up: ', service.name);
    if (service.name.indexOf('BigScreen@') === 0) {
      return servers[service.name] = service;
    }
  });

  browser.on('serviceDown', function(service) {
    console.log('service down: ', service.name);
    if (service.name.indexOf('BigScreen@') === 0) {
      return delete servers[service.name];
    }
  });

  browser.start();

  rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  rl.on("line", function(line) {
    return requestCommand(line.trim());
  });

}).call(this);
